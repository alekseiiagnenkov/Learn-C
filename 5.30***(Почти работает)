/* Вариант 30 ***
Написать программу для работы по запросам оператора с кэшированной упорядоченной таблицей,
реализованной в виде 2.3.4-дерева поиска. Доступ к элементам таблицы (дерева) осуществляется через
дополнительный кэш-буфер, реализованный в виде хэш-таблицы.

Ключи - целые числа. Информация - строка произвольной длины. Узел дерева содержит массив ключей,
массив указателей на поддеревья и указатель наинформационное поле. При необходимости в узел дерева
может быть включен указатель на родительский узел. Элемент кэша содержит ключ и указатель на
соответствующий узел дерева.

В таблице не могут храниться записи с одинаковыми ключами. Размер кэш-буфера ограничен числом N.
Предусмотреть следующие операции:

- включение нового элемента в таблицу без нарушения свойств упорядоченности; если информация с          +
заданным ключом уже есть, то выводится сообщение об ошибке. При включении элемента информация заносится
в кэш буфер; при возникновении коллизии элемент в кэш буфере замещается новым значением, а старое
значение заносится в дерево;
- удаление из таблицы элемента, заданного своим ключом, без нарушения свойств упорядоченности таблицы;  -
- поиск информации по заданному ключу;                                                                  +
- вывод всего содержимого таблицы в прямом порядке следования ключей;                                   +
- возврат элемента, соответствующего ключу с максимальным значением.                                    +

Примечания:
1. Программа должна содержать несколько функций; функция main() должна выполнять: вывод меню,           +
ввод и анализ ответа, вызов на исполнение требуемой функции;                                            
2. В программе нужно предусмотреть проверку правильности ввода данных.                                  +
3. Оценить сложность реализованных алгоритмов.                                                          +
4. Для целей отладки реализовать форматированный вывод таблицы в виде дерева.                           +
5. Для целей отладки реализовать загрузку таблицы из файла в формате:                                   +
•	Ключ 1
•	Информация 1
•	Ключ 2
•   ...
6.	Провести таймирование (или профилирование) программы.                                               +
*/

#define _CRT_SECURE_NO_WARNINGS
#define SIZE 5
#define t 2
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <stdlib.h>
#include < math.h >
/*Максимальный размер таблицы ограничен(для задания максимального размера таблицы использовать константу 
- например const int SIZE = ...;).*/
//структура элемента таблицы
typedef struct Item {
    int key;                 //ключ элемента
    char* info;              //информация элемента
}Item;
//структура узла дерева
typedef struct Node {
    int n;                   //количество ключей в узле
    Item* arr[2*t-1];        //массив Item
    struct Node* ptr[2 * t]; //указатели на дочерние узлы
    struct Node* parent;     //указатель на родительский узел
}Node;
//структура таблицы
typedef struct Table {
    int size;                //максимальный размер таблицы
    int count;               //текущий размер таблицы
    Item** arr;              //указатель на 2 массив ARR
}Table; 
//строки меню
const char* msgs[] = { NULL, "Exit programm", "Generate random table", "Input item", "Delete releases", "Print table", "Find key", "Find MAX key", "Print all keys","Timing"};
//[ФУНКЦИИ МЕНЮ]
void F0_Menu();                         //меню
int F1_End(Table*, Node**);             //функция выхода
int F2_Generate(Table*, Node**);        //генерация рандомных значений в таблице
int F3_Input(Table*, Node**);           //ввод элемента
int F4_DeleteRelease(Table*, Node**);   //удаление элемента
int F5_Print(Table*, Node**);           //вывод элементов
int F6_FindKey(Table*, Node**);         //поиск и копирование элемента
int F7_FindMAX(Table*, Node**);         //поиск максимального ключа
int F8_PrintAllKeys(Table*, Node**);
int F9_Timing();
//[ФУНКЦИИ РАБОТЫ С ТАБЛИЦЕЙ]  
Table* TableCreate(int);               //функция создания пустой таблицы
void TableDelete(Table*);              //удаление таблицы
int TablePrint(Table*, Node*);         //вывод таблицы
int Search(Table*);                    //поиск файла
int load(Table*);                      //загрузка таблицы
int create(Table*, int);               //создание таблицы
Item* MAX(Table*, Node**);       //поиск максимального ключа
int MIN(Table*);                       //определение минимального элемента
int FindKey(Table*, Node**, int, int);
//[ФУНКЦИИ РАБОТЫ С ДЕРЕВОМ]
int AddItemTree(Node*, Item*);         //Добавление элемента в дерево
int OptimizationNode(Node*, Node*);    //Pазбиваем узел вверх
Node* SplitNodeUp(Node*, Node**, Item*);//разбиваем узел вверх
void ShiftNode(Node*, int, int);       //сдвиг элементов в узле  ([1]-влево [2]-вправо)
int SearchPTR(Node*, int);             //поиск нужного поддерева или положения Item
int AddItemNode(Node*, Item*);         //добавление элемета в узел 
void PrintTree(Node*, int);            //вывод дерева 
Node* ProcessingNode(Node*, Node**);            //обработка узла(схлопывание)
Item* FindKeyTree(Node**, int, int);        //поиск ключа в дереве
void DeletTree(Node*);                 //удаление дерева
int CheckTreeFree(Node*);
Node* DeleteKeyTree(Node*, int);
void Redistribution(Node*, int, int);
Node* fixNode(Node*, int);
//[ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ]
int hash(int, Table*);                   //определение ключа 2
int CheckTableFull(Table*);            //переполнение таблицы
int CheckTableFree(Table*);            //пустая таблицы
int choose(Table*);                    //выбор для добавления элементов
int FindKeyTable(Table*, int, int);  //проверка ключа
void DelItem(Item*);
Node* SearchReplacement(Node*, int*, int*);
//[ФУНКЦИИ ВВОДА]
int getInt(int*);                      //чтение целого числа
char* getstr();                        //функция ввода строк

/*1. Программа должна содержать несколько функций; функция main должна выполнять:                        +
вывод меню, ввод и анализ ответа, вызов на исполнение требуемой функции;*/
int main() 
{
    int  menu = -1, ex = 0, flag = 0;
    int(*fun1[]) (Table*, Node**) = { NULL, F1_End, F2_Generate, F3_Input, F4_DeleteRelease, F5_Print, F6_FindKey, F7_FindMAX, F8_PrintAllKeys, F9_Timing };
    Node* root = NULL;
    Table* T = TableCreate(SIZE);//Выделяю память под таблицу
    if (T == NULL) {
        printf("Error!\n");
        return 0;
    }
    F0_Menu();
    //выбор пункта меню
    while (ex != 1) {
        menu = -1;
        flag = 0;
        while (menu <= -1 || menu >= 10) {
            if (flag == 1)
                printf("Error!\n");
            printf("Selected action (0 - Menu):");
            getInt(&menu);
            flag = 1;
        }
        if (menu == 0)
            F0_Menu();
        else {
            ex = (*fun1[menu])(T, &root);
        }
    }
    return 0;
}
//                                            [ФУНКЦИИ МЕНЮ]
//вывод меню                                                                                             +
void F0_Menu()
{
    printf("\n      [MENU]\n");
    for (int i = 1; i < 10; ++i)
        printf("[%d] %s\n", i, msgs[i]);
}
//завершение программы                                                                                   +                                                                        
int F1_End(Table* T, Node** root)
{
    Node* N = *root;
    if (!CheckTreeFree(*root))
        DeletTree(N);
    free(*root);
    printf("The tree was deleted.\n");
    TableDelete(T);
    return 1;
}
//добавление случайных элементов                                                                         +                             
int F2_Generate(Table* T, Node** root)
{
    printf("\n      [GENERATE RANDOM TABLE]");
    int key, n, j, k = 0;
    srand(time(NULL));
    if ((n = choose(T)) == 0)
        return 0;
    for (int i = 0; i < n; i++) {
        Item* I = (Item*)calloc(1, sizeof(Item));
        I->info = (char*)calloc(4, sizeof(char));
        for (j = 0; j < 3; j++) {
            I->info[j] = '0' + rand() % 10;
        }
        I->info[3] = '\0';
        do {
            key = rand() % 1000;
            j = FindKeyTable(T, key, 2, root);
        } while (j == -1);
        if (j) {
            if (AddItemTree(root, T->arr[hash(key, T)]))
                continue;
            k++;
        }
        I->key = key;
        T->arr[hash(key, T)] = I;
        if (T->count < SIZE)
            T->count++;
    }
    printf("[%d] Items was added in the tree.\n", k);
    printf("Success. Added [%d] elements.\n", n);
    return 0;
}
/*-включение нового элемента в таблицу без нарушения свойств упорядоченности; если информация с          +
заданным ключом уже есть, то выводится сообщение об ошибке.При включении элемента информация заносится
в кэш буфер; при возникновении коллизии элемент в кэш буфере замещается новым значением, а старое
значение заносится в дерево*/
int F3_Input(Table* T, Node** root)
{
    printf("\n      [INPUT ITEM]");
    int key, n, k = 0, j;
    char* info;
    if ((n = choose(T)) == 0)
        return 0;
    for (int i = 0, flag = 0; i < n; i++) {
        Item* I = (Item*)calloc(1, sizeof(Item));
        printf("Enter information:");
        info = getstr();
        do {
            if (flag == 1)
                printf("This key has already been added. Repeat!\n");
            flag = 0;
            printf("Enter key:");
            getInt(&key);
            j = FindKeyTable(T, key, 2, root);
        } while (j == -1);
        if (j) {
            printf("Collision of elements.");
            if (AddItemTree(root, T->arr[hash(key, T)])) {
                printf("Error, this key was already added!\n");
                continue;
            }
            printf("The previous Item was added to the tree.");
            k++;
        }
        I->key = key;
        I->info = info;
        if (T->count < SIZE)
            T->count++;
        T->arr[hash(key, T)] = I;
    }
    printf("\n[%d] Items was added in the tree.\n", k);
    if (k != n)
        printf("Success. Added [%d] elements.\n", n);
    return 0;
}
//- удаление из таблицы элемента, заданного своим ключом, без нарушения свойств упорядоченности таблицы  +                                 
int F4_DeleteRelease(Table* T, Node** root)
{
    printf("\n      [DELETED REALEASE]");
    int i, key;
    Node* N = *root;
    if (CheckTableFree(T) == 1)
        return 0;
    printf("\nEnter key:");
    getInt(&key);
    if (FindKeyTable(T, key, 1))
        printf("The key is not found in the kash-table.\n");
    else {
        free(T->arr[hash(key, T)]);
        T->arr[hash(key, T)] = NULL;
        T->count--;
        return 0;
    }
    N = FindKeyTree(root, key, 1);
    if (N == NULL) {
        printf("The key is not found in tree.\n");
        return 0;
    }
    else
        N = DeleteKeyTree(&N, key);
    if (N != NULL) {
        if (N->n != 0) {
            if (N->parent == NULL)
                *root = N;
        }
    }
    else
        *root = NULL;
    N = *root;
    if (N->ptr[0] != NULL)
        if (N->n == 1 && N->ptr[0]->n == 1 && N->ptr[1]->n == 1)
            ProcessingNode(*root, root);
    printf("The Item was deleted.\n");
    return 0;
}
//-вывод всего содержимого таблицы в прямом порядке следования ключей                                    +
int F5_Print(Table* T, Node** root)
{
    printf("\n      [PRINT TABLE]");
    if (CheckTableFree(T) == 1)
        return 0;
    TablePrint(T, root); //вывод
    printf("\nTree:\n");
    if (CheckTreeFree(*root))
        return 0;
    PrintTree(*root, 0);
    return 0;
}
//-поиск информации по заданному ключу                                                                   +
int F6_FindKey(Table* T, Node** root)
{
    printf("\n      [FIND KEY]\n");
    int key, k;
    char* info;
    if (CheckTableFree(T) == 1)
        return 0;
    printf("Enter key:");
    getInt(&key);
    FindKey(T, root, key, 1);
    return 0;
}
// Вывод максимального элемента                                                                          +   
int F7_FindMAX(Table* T, Node** root) {
    printf("\n      [FIND MAX KEY]\n");
    if (CheckTableFree(T) == 1)
        return 0;
    Item* I = MAX(T, root);
    printf("Key:%d\nInfo:%s\n", I->key, I->info);
}
//Вывод всех ключей                                                                                      +
int F8_PrintAllKeys(Table* T, Node** root)
{
    printf("\n      [PRINT ALL KEYS]\n");
    int key1 = 0, key2, i, j, k, MAX=1000000000;
    if (CheckTableFree(T) == 1)
        return 0;
    Node* N = *root;
    for (i = 0; i <= T->count; i++) {
        if (i == 0)
            key1 = 0;
        else
            key1 = key2;
        k = -1;
        do {
            k++;
            if (k >= T->size)
                break;
            while (T->arr[k] == NULL)
                k++;
        } while (T->arr[k]->key <= key1);
        if (k < T->size)
            key2 = T->arr[k]->key;
        else
            key2 = MAX;
        for (j = 0; j < T->size; j++)
            if (T->arr[j] != NULL)
                if (T->arr[j]->key > key1)
                    if (T->arr[j]->key < key2)
                        key2 = T->arr[j]->key;
        MIN(N, key1, key2);
        if (key2!=MAX)
        printf("key:%d\n", key2);
    }
    return 0;
}
//Таймирование                                                                                           +
int F9_Timing()
{
    printf("\n      [TAIMING]\n");
    Node* root = NULL;
    Item* I;
    int n = 100, k, cnt = 50000, i, m, j, size=50000;
    int* key = (int*)malloc(sizeof(int)*10000);
    clock_t first, last;
    Table* T = (Table*)malloc(sizeof(Table));
    create(T, size);
    srand(time(NULL));
    while (n-- > 0) {
        for (i = 0; i < 10000; ++i)
            key[i] = rand() * rand();
        for (i = 0; i < cnt; ) {
            I = (Item*)calloc(1, sizeof(Item));
            do {
                I->key = rand() * rand();
                j = FindKeyTable(T, I->key, 2, root);
            } while (j == -1);
            if (j) {
                if (AddItemTree(&root, T->arr[hash(I->key, T)])) {
                    i++;
                    continue;
                }
            }
            T->arr[hash(I->key, T)] = I;
            if (T->count < size)
                T->count++;
                ++i;
        }
        m = 0;
        first = clock();
        for (i = 0; i < 10000; ++i)
            if (!(FindKey(T, &root, key[i], 2)))
                m++;
        last = clock();
        printf("\n%d items was found\n", m);
        printf("test #%d, number of nodes = %d, time = %d\n", 100 - n, (100 - n) * cnt, last - first);
        //printf("Theoretical value:%lf\n\n", log2((10-n)*cnt/3));
    }
    DeletTree(root);
    TableDelete(T);
    return 0;
}
//                                      [ФУНКЦИИ РАБОТЫ С ДЕРЕВОМ]
//Добавление элемента в дерево                      +    
int AddItemTree(Node** root, Item* I)
{
    int flag = 0;
    if (*root == NULL)
        *root = (Node*)calloc(1, sizeof(Node));
    Node* N = *root;
    do {
        while (N->ptr[0] != NULL)             //если имеет дочерние узлы
            N = N->ptr[SearchPTR(N, I->key)]; //переход на следующий узел
        if (N->n == 3) {                      //Если в узле 3 элемента
            N = SplitNodeUp(N, root, I);
        }
        else
            flag = 1;
    } while (!flag);
    if (AddItemNode(N, I))
        return 1;
    return 0;
}
//разбиваем узел вверх                              +
Node* SplitNodeUp(Node* n1, Node** root, Item* I)
{//n1-текущий, N-выше на 1 чем n1, n2- соседний с n1
    Node* n2 = (Node*)calloc(1, sizeof(Node));
    if (n1->parent == NULL) {
        Node* N = (Node*)calloc(1, sizeof(Node));
        N->arr[0] = n1->arr[1];
        N->n = 1;
        N->ptr[0] = n1;
        N->ptr[1] = n2;
        n2->parent = N;
        n1->parent = N;
        *root = N;
    }
    else {
        if (n1->parent->n == 3)
            n1->parent = SplitNodeUp(n1->parent, root, I);
        int i = SearchPTR(n1->parent, n1->arr[1]->key);
        if (n1->parent->arr[i] != NULL)
            ShiftNode(n1->parent, 2, i);
        n1->parent->arr[i] = n1->arr[1];
        n1->parent->n++;
        n1->parent->ptr[i] = n1;
        n1->parent->ptr[i + 1] = n2;
        n2->parent = n1->parent;
    }
    n1->arr[1] = NULL;
    n2->arr[0] = n1->arr[2];
    if (n1->arr[2] != NULL) {
        if (n1->ptr[2] != NULL && n1->ptr[3] != NULL) {
            n1->ptr[2]->parent = n2;
            n1->ptr[3]->parent = n2;
        }
    }
    n2->n = 1;
    n1->arr[2] = NULL;
    n2->ptr[0] = n1->ptr[2];
    n2->ptr[1] = n1->ptr[3];
    n1->ptr[2] = NULL;
    n1->ptr[3] = NULL;
    n1->n = 1;
    return n1->parent->ptr[SearchPTR(n1->parent, I->key)];
}
//сдвиг элементов в узле  [1]-влево [2]-вправо      +
void ShiftNode(Node* N, int a, int b)
{
    int i;
    if (a == 1)
        for (i = 0; N->arr[b] != NULL; i++) {
            if (N->arr[i + 1] == NULL)
                continue;
            N->arr[i] = N->arr[i + 1];
            N->arr[i + 1] = NULL;
            if (N->ptr[i] == NULL) {
                N->ptr[i] = N->ptr[i + 1];
                N->ptr[i + 1] = NULL;
            }
            if (N->ptr[i + 1] == NULL) {
                N->ptr[i + 1] = N->ptr[i + 2];
                N->ptr[i + 2] = NULL;
            }
            if (N->ptr[i] == NULL && N->ptr[i + 1] != NULL) {
                N->ptr[i] = N->ptr[i + 1];
                N->ptr[i + 1] = NULL;
            }
        }
    else
        for (i = 2; N->arr[b] != NULL; i--) {
            if (N->arr[i - 1] == NULL)
                continue;
            N->arr[i] = N->arr[i-1];
            if (N->ptr[i + 1]==NULL)
            N->ptr[i+1] = N->ptr[i];
            N->ptr[i] = N->ptr[i - 1];
            N->arr[i-1] = NULL;
            N->ptr[i-1] = NULL;
        }
}
//поиск нужного указателя или положения Item        +
int SearchPTR(Node* N, int k)
{
    int i = 0, j = 0;
    while (N->arr[i] != NULL && j < 3) {
        if (k > N->arr[i]->key)
            i++;
        j++;
    }
    return i;
}
//добавление элемета в узел                         +
int AddItemNode(Node* N, Item* I)
{
    int i = SearchPTR(N, I->key);
    if (N->arr[i] != NULL)
        if (N->arr[i]->key == I->key)
            return 1;
        else
            ShiftNode(N, 2, i);
    N->arr[i] = I;
    N->n++;
    return 0;
}
//обработка узла(схлопывание)                       + 
Node* ProcessingNode(Node* N, Node** root)
{
    Node* n = N->ptr[0];
    N->ptr[0]->arr[1] = N->arr[0];
    N->ptr[0]->arr[2] = N->ptr[1]->arr[0];
    N->ptr[0]->ptr[2] = N->ptr[1]->ptr[0];
    N->ptr[0]->ptr[3] = N->ptr[1]->ptr[1];
    N->ptr[0]->n = 3;
    free(N->ptr[1]);
    N->ptr[1] = NULL;
    N = N->ptr[0];
    free(N->parent);
    N->parent = NULL;
    if (N->parent == NULL) {
        if (*root != N) {
            *root = N;
            return N;
        }
        else
            return N;
    }
        //else {
        //    N->ptr[0]->parent = N->parent;
        //    N->parent->ptr[SearchPTR(N->parent, N->arr[0]->key)] = N->ptr[0];
        //    free(N);
        //}
    return N->parent;
}
//вывод дерева                                      +
void PrintTree(Node* N, int level)
{
    if (N != NULL) {                           //Пока не встретится пустой узел
        for (int k = 3; k >= 0; k--) {
            PrintTree(N->ptr[k], (level + 1)); //Рекурсивная функция
            if (k>0)
                if (N->arr[k-1] != NULL) {
                    for (int j = 0; j <= level; j++)
                        printf("        ");
                    printf("key:%d\n", N->arr[k-1]->key);
                }
        }
    }
}
//поиск ключа в дереве                              +
Item* FindKeyTree(Node** root, int key, int a)
{
    Node* N = *root;
    if (CheckTreeFree(*root))
        return 0;
    while (1) {
        int i = SearchPTR(N, key);
        if (N->arr[i] != NULL) {   //если имеет дочерние узлы
            if (N->arr[i]->key == key)
                if (a == 1)
                    return N;
                else
                    return N->arr[i];
            else
                if (N->ptr[i] == NULL)
                    return NULL;
        }
        if (N->ptr[0] != NULL)
            N = N->ptr[i];         //переход на следующий узел
        else
            return NULL;
    }
}
//удаление дерева                                   +
void DeletTree(Node* N)
{
    if (N != NULL) {                       //Пока не встретится пустой узел
        for (int k = 3; k >= 0; k--) {
            if (N->ptr[k] != NULL) {
                DeletTree(N->ptr[k]); //Рекурсивная функция
                for (int i = 0; i < 3; i++)
                    free(N->ptr[k]->arr[i]);
                free(N->ptr[k]);
                N->ptr[k] = NULL;
            }
        }
    }
}
//удаление элемента из дерева                       ?
Node* DeleteKeyTree(Node** root, int key)
{
    Node* n = *root; //нужен для преобразований и поиска
    Node* N = *root; //указывает на узел с удаляемым элементом
    Node* n1 = *root;
    int i = SearchPTR(n, key), j = 1, k = 1, flag = 1, h=0;
    if (n->ptr[0] != NULL) {             //если имеет поддеревья, то ищем замену
        j = 0;
        h = i;
        n = SearchReplacement(n, &h, key);
        if (n == NULL) {
            free(N->arr[0]);
            free(N);
            return NULL;
        }
        DelItem(N->arr[i]);
        if (h == 0)
            h++;
        N->arr[i] = n->arr[h - 1];
        key = n->arr[h - 1]->key;        //теперь нам нужно преобразовать B-дерево
        i = h - 1;
    }
    if (n->ptr[0] == NULL) {             //если не имеет поддеревьев
        if (j)
            DelItem(n->arr[i]);
        n->arr[i] = NULL;
        n->n--;
        if (n->n > 0)                    //если он был не один в узле
            ShiftNode(n, 1, n->n);
        else {                           //если он был единственным в узле
            if (n->parent != NULL) {
                n1 = n;
                n = fixNode(n->parent, SearchPTR(n->parent, key), key); //возвращает родителя
                if (n->parent != NULL)
                    if (n->parent->n == 0) {
                        free(n->parent);
                        n->parent = NULL;
                        N = n;
                    }
                while (n->n == 0)            //пока в узле 0 элементов
                    if (n->parent != NULL) { //если родитель есть
                        n = fixNode(n->parent, SearchPTR(n->parent, key), key);//возвращает родителя
                        continue;
                    }
                    else {                   //если родителя нет 
                        N = n;
                        break;
                    }
                ShiftNode(n, 2, n->n);
            }
        }
    }
    if (N->n == 0) {
        n1 = NULL;
        free(N);
        if (N == n)
            n = NULL;
        N = NULL;
        return n;
    }
    return N;
}
/*изменение дерева (i=0-поворот ключей вправо,      ?
для остальных случаев влево), поступает родитель*/ 
Node* fixNode(Node* n, int i, int key) 
{//0<=i<=3
    Node* N;
    int flag = 0, j=0;
    while (flag == 0) {
        if (n->arr[i] == NULL || i==3) { //поворот влево
            if (n->ptr[i - 1]->n > 1)    //если в узле, в сторону которого выполняется поворот находится 3 элемента, то 
                i--;
            else { //если все хорошо
                n->ptr[i - 1]->arr[SearchPTR(n->ptr[i - 1], n->arr[i - 1]->key)] = n->arr[i - 1];
                n->ptr[i - 1]->n++;
                n->arr[i - 1] = n->ptr[i]->arr[0];
                n->ptr[i]->arr[0] = NULL;
                if (n->ptr[i]->n>1)
                n->ptr[i]->n--;
                if (n->ptr[i]->n > 0)
                    ShiftNode(n->ptr[i], 1, n->ptr[i]->n);
                else
                    n->ptr[i] = NULL;
                n->n--;
                flag = 1;
            }
        }
        else {     //поворот вправо
            if (n->ptr[i + 1] != NULL)
                if (n->ptr[i + 1]->n > 1) {
                    if (i != 0)
                        i--;
                    else {
                        i++;
                        continue;
                    }
                }
            if (n->ptr[i + 1]!=NULL)
            ShiftNode(n->ptr[i + 1], 2, 0);
            n->ptr[i + 1]->arr[0] = n->arr[i];
            n->ptr[i + 1]->n++;
            if (n->ptr[i]->n > 0) {
                n->arr[i] = n->ptr[i]->arr[n->ptr[i]->n - 1];
                n->ptr[i]->arr[n->ptr[i]->n - 1] = NULL;
                n->ptr[i]->n--;
            }
            else {
                n->arr[i] = NULL;
                n->ptr[i] = NULL;
            }
            if (n->arr[i]==NULL)
            n->n--;
            if (n->n!=3)
            ShiftNode(n, 1, n->n);
            flag = 1;
            if (i<3)
                if (n->ptr[i + 1]->parent->arr[i] == NULL) {
                    n->ptr[i] = n->ptr[i + 1];
                    n->ptr[i + 1] = NULL;
                }
        }
        for (j = 0; n->arr[j] != NULL; j++); //cчитаем кол-во узлов в узле
        n->n = j;
    }
    if (n->n == 0) {
        if (n->parent == NULL)
            return n->ptr[0];
    }

    return n;
}
//поиск замены (возвращает элемент, из которого нужно взять Item) +
Node* SearchReplacement(Node* n, int* i, int key)
{
    Node* N = n;
    Node* n1 = N;
    int k = 1, j = 1, l = 0;
    if (n->ptr[0] != NULL) {              //если существуют дочерние узлы
        n = n->ptr[*i + 1];
        while (n->ptr[0] != NULL) {       //пока не найдем минимальный ключ в правом поддереве
            n = n->ptr[0];
            j++;
        }
        if (n->n == 1) {                  //если он 1, то можно поискать в левом поддереве
            n1 = N;
            k = *i;
            while (n1->ptr[k] != NULL) {  //пока не найдем минимальный ключ в левом поддереве
                n1 = n1->ptr[k];
                k = n->n;
                l++;
            }
            k = 0;
            while (n1->arr[k] != NULL && k < 3) //находим максимальный ключ последнем узле левого поддерева
                k++;
            *i = k;
        }
        if (j <= l)
            n = n1;
    }
    else {   //если дочерние элементы не существуют
        if (n->parent != NULL) {
            n = n->parent;
            n1 = n;
            *i = SearchPTR(n, key);
            if (*i > 0 && *i < 3) //если справа и слева есть элемент, то возвращаем их
                return n;
            else { //Если одного из родителей нет, то
                if (*i == 0) {
                    n1 = n;
                    if (n->ptr[*i + 1]->n > 1)  //если у брата справа больше 1 Item
                        return n;
                    while (n->parent != NULL) { //поиск замены
                        n = n->parent;
                        if (n->arr[SearchPTR(n, key) - 1]->key < key) {
                            j = 0;
                            break;
                        }
                    }
                }
                else {
                    n1 = n;
                    if (n->ptr[*i - 1]->n > 1)  //если у брата слева больше 1 Item
                        return n;
                    while (n->parent != NULL) { //поиск замены
                        n = n->parent;
                        *i = SearchPTR(n, key);
                        if (i < 3)
                            if (n->arr[*i]->key > key) {
                                j = 0;
                                break;
                            }
                    }
                }
                if (j) //если не нашли замену, то возвращаем родителя
                    return n1;
                if (n1->n > n->n)
                    return n1;
                else
                    return n;
            }
        }
        return NULL;
    }
    return n;
}
//удаление элемента                                 +
void DelItem(Item* I)  
{
    free(I->info);
    free(I);
}
//                                      [ФУНКЦИИ РАБОТЫ С ТАБЛИЦЕЙ]
int FindKey(Table* T, Node** root, int key, int a)
{
    Item* I;
    if (a == 1) {
        printf("Kash-table:\n");
        if (FindKeyTable(T, key, 1, root))
            printf("The key is not found in the kash-table.\n");
        else {
            printf("Info:%s\n", T->arr[hash(key, T)]->info);
            return 0;
        }
        printf("Tree:\n");
        I = FindKeyTree(root, key, 0);
        if (I == NULL)
            printf("The key is not found in the tree.\n");
        else
            printf("Key:%d\nInfo:%s\n", I->key, I->info);
        return 0;
    }
    else {
        if (!FindKeyTable(T, key, 1, root))
            return 0;
        else
            if (FindKeyTree(root, key, 0) != NULL)
                return 0;
            else
                return 1;
    }
}
//выделение памяти под структуру и пустые массивы   +         
Table* TableCreate(int size)
{
    Table* T;
    if (size <= 0)
        return NULL;
    T = (Table*)calloc(1, sizeof(Table));//выделяем память под структуру таблицы
    if (T == NULL)
        return NULL;
    if (Search(T))
        return NULL;
    return T;
}
//удаление таблицы                                  +           
void TableDelete(Table* T)
{
    int i = 0;
    if (CheckTableFree(T) == 1)
        return 0;
    while (T->arr[i] != NULL && i < T->size) {
        if (T->arr[i]->info != NULL)
            free(T->arr[i]->info);
        free(T->arr[i]);
        T->arr[i] = NULL;
        i++;
    }
    T->count = 0;
    free(T->arr);
    free(T);
    printf("Table was deleted.\n\n");
}
//вывод таблицы                                     +                                              
int TablePrint(Table* T, Node** root)
{
    int k, i;
    puts("\nTable:");
    printf("count = %d, size = %d.\n", T->count, T->size);
    printf("%2s %5s %8s\n", "i", "key2", "info");
    for (i = 0; i < T->count; i++) {     //проходим по массиву
        printf("%2d", i);
        if (T->arr[i] != NULL)
            printf("%5d  %8s\n", T->arr[i]->key, T->arr[i]->info);
        else
            printf("%5d    (null)\n", 0);
    }
    for (i; i < T->size; i++) {
        printf("%2d", i);
        printf("%5d    (null)\n", 0);
    }
    return 0;
}
//загрузка таблицы                                  +  
int Search(Table* T)
{
    int choose=1;
    printf("Upload data from a file?\nYes[1]    No[2]\nEnter:");
    do {
        if (choose != 1 && choose != 2)
            printf("Error! Repeat:");
        getInt(&choose);
        if (choose == 0 || choose == 2) {
            create(T, SIZE);
            return 0;
        }
    } while (choose != 1 && choose != 2);
    if (load(T) == 0) { //если такого файла нет, то создаем таблицу
        printf("File wasn't found.");
        create(T, SIZE);
    }
    return 0;
}
//считываем информацию из файла(если он существует) +                     
int load(Table* T)
{
    int i = 0, j;
    char a[4];
    FILE* file = fopen("1.txt", "r");
    fscanf(file, "%d%d", &T->size, &j);
    T->count = 0;
    T->arr = (Item*)calloc(T->size, sizeof(Item));
    for (int i = 0; i < j; i++) {
        Item* I = (Item*)calloc(1, sizeof(Item));
        I->info = (char*)calloc(4, sizeof(char));
        fscanf(file, "%d%s", &I->key, I->info);
        T->arr[hash(I->key, T)] = I;
        T->count++;
    }
    fclose(file);
    return 1;
}
//создаем новую таблицу                             +   
int create(Table* T, int sz)
{
    T->size = sz;
    T->count = 0;
    T->arr = (Item*)calloc(T->size, sizeof(Item));
    if (T->arr == NULL)
        return 1;
    return 0;
}
/*вывод всех ключей в порядке возрастания           +
key1-от какого, key2-до какого (key1 < key2)*/
int MIN(Node* N, int key1, int key2)
{
    if (N != NULL) {                        //Пока не встретится пустой узел
        for (int k = 0; k <= 3; k++) {
            if (MIN(N->ptr[k], key1, key2)) //Рекурсивная функция
                return 1;
            if (k<3)
            if (N->arr[k] != NULL) {
                if (N->arr[k]->key > key1)
                    if (N->arr[k]->key < key2)
                printf("key:%d\n", N->arr[k]->key);
                else
                    return 1;
            }
        }
    }
    return 0;
}
/*-возврат элемента, соответствующего               +
ключу с максимальным значением*/   
Item* MAX(Table* T, Node** root)
{
    int kMAX, k = 0, o, j;
    while (T->arr[k] == NULL)
        k++;
    kMAX = T->arr[k]->key;
    o = k;
    for (k = 1; k < T->size; k++) {
        if (T->arr[k] != NULL)
            if (T->arr[k]->key > kMAX) {
                kMAX = T->arr[k]->key;
                o = k;
            }
    }
    if (*root==NULL)
        return T->arr[o];
    Node* N = *root;
    while (1) {
        for (j = 0; N->arr[j] != NULL && j < 3; j++);
        if (N->ptr[j] != NULL)
            N = N->ptr[j];
        else
            break;
    }
    if (T->arr[o]->key > N->arr[j - 1]->key)
        return T->arr[o];
    return N->arr[j - 1];
}
//                                           [ФУНКЦИИ ВВОДА]
//чтение целого числа                               +         
int getInt(int* a)
{
    int n, flag = 0;
    do
    {
        if (flag == 1) {
            printf("Error!\nRepeat:");
            scanf_s("%*[^\n]");
        }
        n = scanf("%d", a);
        if (*a == -1)
            n = -1;
        flag = 1;
    } while (n <= 0);
    scanf("%*c");
    return n;
}
//получаем строку из входного потока                +  
char* getstr()
{
    char* ptr = (char*)malloc(1);
    char buf[81];
    int n, len = 0;
    *ptr = '\0';
    do {
        n = scanf("%80[^\n]", buf);
        if (n < 0) {
            free(ptr);
            ptr = NULL;
            continue;
        }
        if (n == 0)
            scanf("%*c");
        else {
            len += strlen(buf);
            ptr = (char*)realloc(ptr, len + 1);
            strcat(ptr, buf);
        }
    } while (n > 0);
    return ptr;
}
//                                       [ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ]
//Выбор                                             +               
int choose(Table* T) {
    int n, m;
    printf("\nMax size of kash-table:[%d]", SIZE);
    printf("\nHow many Items do you want to add?\nEnter:");
    getInt(&n);
    if (n == 0)
        return 0;
    return n;
}
//хеш функция                                       + 
int hash(int key, Table* T)
{
    return key % T->size;
}
//Поиск ключа в кеш таблице                         +
int FindKeyTable(Table* T, int key, int a) {
    int i = hash(key, T), j;
    if (a == 1) {
        if (T->arr[i] != NULL) {
            if (T->arr[i]->key != key)
                return 1;
        }
        else
            return 0;
    }
    else {
        if (T->arr[i] != NULL) {
            if (T->arr[i]->key == key)
                return -1;
            else
                return 1;
        }
    }
    return 0;
}
//пустая таблица                                    + 
int CheckTableFree(Table* T)
{
    if (T->count == 0) {
        puts("\nTable is free.");
        return 1;
    }
    return 0;
}
//пустое дерево                                     +
int CheckTreeFree(Node* root)
{
    if (root == NULL) {
        printf("Tree is free.\n");
            return 1;
    }
    return 0;
}
