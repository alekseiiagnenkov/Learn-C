/* Вариант 30 ***
Написать программу для работы по запросам оператора с кэшированной упорядоченной таблицей,
реализованной в виде 2.3.4-дерева поиска. Доступ к элементам таблицы (дерева) осуществляется через
дополнительный кэш-буфер, реализованный в виде хэш-таблицы.

Ключи - целые числа. Информация - строка произвольной длины. Узел дерева содержит массив ключей,
массив указателей на поддеревья и указатель наинформационное поле. При необходимости в узел дерева
может быть включен указатель на родительский узел. Элемент кэша содержит ключ и указатель на
соответствующий узел дерева.

В таблице не могут храниться записи с одинаковыми ключами. Размер кэш-буфера ограничен числом N.
Предусмотреть следующие операции:

- включение нового элемента в таблицу без нарушения свойств упорядоченности; если информация с
заданным ключом уже есть, то выводится сообщение об ошибке. При включении элемента информация заносится
в кэш буфер; при возникновении коллизии элемент в кэш буфере замещается новым значением, а старое
значение заносится в дерево;
- удаление из таблицы элемента, заданного своим ключом, без нарушения свойств упорядоченности таблицы;
- поиск информации по заданному ключу;
- вывод всего содержимого таблицы в прямом порядке следования ключей;
- возврат элемента, соответствующего ключу с максимальным значением.

Примечания:
1. Программа должна содержать несколько функций; функция main() должна выполнять: вывод меню,
ввод и анализ ответа, вызов на исполнение требуемой функции;
2. В программе нужно предусмотреть проверку правильности ввода данных.
3. Оценить сложность реализованных алгоритмов.
4. Для целей отладки реализовать форматированный вывод таблицы в виде дерева.
5. Для целей отладки реализовать загрузку таблицы из файла в формате:
•	Ключ 1
•	Информация 1
•	Ключ 2
•   ...
6.	Провести таймирование (или профилирование) программы.
*/

#define _CRT_SECURE_NO_WARNINGS
#define SIZE 5
#define t 2
#include <stdio.h>
#include <string.h>
/*Максимальный размер таблицы ограничен(для задания максимального размера таблицы использовать константу -
например const int SIZE = ...;).*/
//структура элемента таблицы
typedef struct Item {
    int key;                 //ключ элемента
    char* info;              //информация элемента
}Item;
//структура узла дерева
typedef struct Node {
    int n;                   //количество ключей в узле
    Item** arr;              //массив Item
    struct Node* ptr[2 * t]; //указатели на дочерние узлы
    struct Node* parent;     //указатель на родительский узел
}Node;
//структура таблицы
typedef struct Table {
    int size;                //максимальный размер таблицы
    int count;               //текущий размер таблицы
    Item** arr;              //указатель на 2 массив ARR
}Table; 
//строки меню
const char* msgs[] = { NULL, "Exit programm", "Generate random table", "Input item", "Delete releases", "Print table", "Find key", "Find MAX key" };
//[ФУНКЦИИ МЕНЮ]
void F0_Menu();                        //меню
int F1_End(Table*, Node*);             //функция выхода
int F2_Generate(Table*, Node*);        //генерация рандомных значений в таблице
int F3_Input(Table*, Node*);           //ввод элемента
int F4_DeleteRelease(Table*, Node*);   //удаление элемента
int F5_Print(Table*, Node*);           //вывод элементов
int F6_FindKey(Table*, Node*);         //поиск и копирование элемента
int F7_FindMAX(Table*, Node*);         //поиск максимального ключа
//[ФУНКЦИИ РАБОТЫ С ТАБЛИЦЕЙ]  
Table* TableCreate(int);        //функция создания пустой таблицы
void TableDelete(Table*, Node*);//удаление таблицы
int TablePrint(Table*, Node*);  //вывод таблицы
int Search(Table*);             //поиск файла
int load(Table*);               //загрузка таблицы
int create(Table*, int);        //создание таблицы
Item* MAX(Table*, int*, Node*); //поиск максимального ключа
int* MIN(Table*);               //определение минимального элемента
//[ФУНКЦИИ РАБОТЫ С ДЕРЕВОМ]
int AddItemTree(Node*, Item*);  //Добавление элемента в дерево
int SplitNode(Node*);           //Разбиение ключа
int OptimizationNode(Node*, Node*);
int SplitNodeUp(Node*);
void ShiftNode(Node*, int);
int SearchPTR(Node*, int);
void AddItemNode(Node*, Item*);
//[ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ]
int hash(int*, int);            //определение ключа 2
int CheckTableFull(Table*);     //переполнение таблицы
int CheckTableFree(Table*);     //пустая таблицы
int choose(Table*);             //выбор для добавления элементов
int FindKey(Table*, int, int, Node*);  //проверка ключа
//[ФУНКЦИИ ВВОДА]
int getInt(int*);               //чтение целого числа
char* getstr();                 //функция ввода строк

/*1. Программа должна содержать несколько функций; функция main должна выполнять:                        +
вывод меню, ввод и анализ ответа, вызов на исполнение требуемой функции;*/
int main() 
{
    int  menu = -1, ex = 0, flag = 0;
    int(*fun1[]) (Table*, Node*) = { NULL, F1_End, F2_Generate, F3_Input, F4_DeleteRelease, F5_Print, F6_FindKey, F7_FindMAX };
    //Выделяю память пол 1 узел
    Node* Nhead = (Node*)calloc(1, sizeof(Node));
    Nhead->arr = (Item*)calloc(3, sizeof(Item));
    //Выделяю память под таблицу
    Table* T = TableCreate(SIZE);
    if (T == NULL) {
        printf("Error!\n");
        return 0;
    }
    F0_Menu();
    //выбор пункта меню
    while (ex != 1) {
        menu = -1;
        flag = 0;
        while (menu <= -1 || menu >= 8) {
            if (flag == 1)
                printf("Error!\n");
            printf("Selected action (0 - Menu):");
            getInt(&menu);
            flag = 1;
        }
        if (menu == 0)
            F0_Menu();
        else {
            ex = (*fun1[menu])(T, Nhead);
        }
    }
    return 0;
}
//                                            [ФУНКЦИИ МЕНЮ]
//вывод меню                                                                                             +
void F0_Menu()
{
    printf("\n      [MENU]\n");
    for (int i = 1; i < 8; ++i)
        printf("[%d] %s\n", i, msgs[i]);
}
//завершение программы                                      '\t'                                                                                                                    
int F1_End(Table* T, Node* Nhead)
{
    TableDelete(T, Nhead);
    return 1;
}
//добавление случайных элементов                                                                         +                             
int F2_Generate(Table* T, Node* Nhead)
{
    printf("\n      [GENERATE RANDOM TABLE]");
    int key, n, j, k=0;
    if ((n = choose(T)) == 0)
        return 0;
    for (int i = 0; i < n; i++) {
        Item* I = (Item*)calloc(1, sizeof(Item));
        I->info = (char*)calloc(4, sizeof(char));
        for (j = 0; j < 3; j++) {
            I->info[j] = '0' + rand() % 10;
        }
        I->info[3] = '\0';
        do {
            key = rand() % 1000;
        } while (FindKey(T, key, 2, Nhead) == -1);
        if (FindKey(T, key, 2, Nhead)) {
            AddItemTree(Nhead, T->arr[hash(&key, SIZE)]);
            k++;
        }
        I->key = key;
        T->arr[hash(&key, SIZE)] = I;
        T->count++;
    }
    printf("[%d] Items was added in the tree.\n", k);
    printf("Success. Added [%d] elements.\n", n);
    return 0;
}
/*-включение нового элемента в таблицу без нарушения свойств упорядоченности; если информация с          +
заданным ключом уже есть, то выводится сообщение об ошибке.При включении элемента информация заносится
в кэш буфер; при возникновении коллизии элемент в кэш буфере замещается новым значением, а старое
значение заносится в дерево*/
int F3_Input(Table* T, Node* Nhead)
{
    printf("\n      [INPUT ITEM]");
    int key, n, k;
    char* info;
    if ((n = choose(T)) == 0)
        return 0;
    for (int i = 0, flag = 0; i < n; i++) {
        Item* I = (Item*)calloc(1, sizeof(Item));
        printf("Enter information:");
        info = getstr();
        do {
            if (flag == 1)
                printf("This key has already been added. Repeat!\n");
            flag = 0;
            printf("Enter key:");
            getInt(&key);
        } while (FindKey(T, key, 2, Nhead) == -1);
        if (FindKey(T, key, 2, Nhead)) {
            printf("Сollision of elements.");
            AddItemTree(Nhead, T->arr[hash(&key, SIZE)]);
            printf("The previous Item was added to the tree.");
        }
        I->key = key;
        I->info = info;
        T->count++;
        T->arr[hash(&key, SIZE)] = I;
    }
    printf("Success. Added [%d] elements.\n", n);
    return 0;
}
//- удаление из таблицы элемента, заданного своим ключом, без нарушения свойств упорядоченности таблицы                                    
int F4_DeleteRelease(Table* T, Node* Nhead)
{
    printf("\n      [DELETED REALEASE]");
    int i, key;
    if (CheckTableFree(T) == 1)
        return 0;
    printf("\nEnter key:");
    getInt(&key);
    if (FindKey(T, key, 1, Nhead)) {
        printf("The key is not found.\n");
        return 0;
    }
    T->arr[hash(&key, SIZE)] = NULL;
    T->count--;
    printf("The Item was deleted.\n");
    return 0;
}
//-вывод всего содержимого таблицы в прямом порядке следования ключей                                    
int F5_Print(Table* T, Node* Nhead)
{
    printf("\n      [PRINT TABLE]");
    if (CheckTableFree(T) == 1)
        return 0;
    TablePrint(T, Nhead); //вывод
    return 0;
}
//-поиск информации по заданному ключу              
int F6_FindKey(Table* T, Node* Nhead)
{
    printf("\n      [FIND KEY]\n");
    int key;
    char* info;
    if (CheckTableFree(T) == 1)
        return 0;
    printf("Enter key:");
    getInt(&key);
    if (FindKey(T, key, 1, Nhead)) {
        printf("The key is not found.\n");
        return 0;
    }
    printf("\nInfo:%s\n", T->arr[hash(&key, SIZE)]->info);
    return 0;
}
// Вывод максимального элемента                     
int F7_FindMAX(Table* T, Node* Nhead) {
    printf("\n      [FIND MAX KEY]\n");
    int i = 0;
    if (CheckTableFree(T) == 1)
        return 0;
    Item* I = MAX(T, &i, Nhead);
    printf("Key:%d\nInfo:%s\n", I->key, I->info);
}
//                                      [ФУНКЦИИ РАБОТЫ С ДЕРЕВОМ]
//Добавление элемента в дерево (добавление 4 элементов- нормально)
int AddItemTree(Node* Nhead, Item* I)
{
    int i = 0, j = 0, flag = 0;
    Node* N = Nhead;
    //происходит только при добавлении первого элемента
    if (N->arr[0] == NULL && N->arr[1] == NULL && N->arr[2] == NULL) {
        N->arr[0] = I;
        N->n = 1;
        return 0;
    }
    else {
        do {
            while (N->ptr[0] != NULL) { //если имеет дочерние узлы
                N = N->ptr[SearchPTR(N, I->key)];//переход на следующий узел
            }
            if (N->n == 3)//Если в узле 3 элемента
                if (N->parent != NULL) {
                    if (N->parent->n = 3) {//если 3 элемента в верхнем узле, тогда разбиваем его
                        SplitNodeUp(N->parent);
                        SplitNodeUp(N);
                    }
                    if (N->parent->n < 3) {//Если в родительском меньше 3 Item, то
                        OptimizationNode(N->parent, N);
                        N = N->parent;
                        flag = 1;
                        continue;
                    }
                }
                else {
                    SplitNode(N);
                    flag = 1;
                }
            else
                flag = 1;
        } while(!flag);
        AddItemNode(N, I);
    }
    return 0;
}
//Оптимизация
int OptimizationNode(Node* N, Node* n1)
{//n1-текущий, N-выше на 1 чем n1
    Node* n2 = (Node*)calloc(1, sizeof(Node));
    n2->arr = (Item*)calloc(3, sizeof(Item));
    n2->arr[0] = n1->arr[2];
    n2->n = 1;
    n1->arr[2] = NULL;
    if (N->arr[SearchPTR(N, n1->arr[1]->key)] != NULL) { //Если элемент нужно вставить на место другого
        ShiftNode(N, 2);
    }
    N->arr[SearchPTR(N, n1->arr[1]->key)] = n1->arr[1];
    N->n++;
    n1->arr[1] = NULL;
    n1->n = 1;
    N->ptr[SearchPTR(N, n1->arr[0]->key)] = n1;
    N->ptr[SearchPTR(N, n2->arr[0]->key)] = n1;
    return 0;
}
//разбиваем узел вверх
int SplitNodeUp(Node* n1)
{//n1-текущий, N-выше на 1 чем n1, n2- соседний с n1
    Node* N = (Node*)calloc(1, sizeof(Node));
    N->arr = (Item*)calloc(3, sizeof(Item));
    Node* n2 = (Node*)calloc(1, sizeof(Node));
    n2->arr = (Item*)calloc(3, sizeof(Item));
 
    N->arr[0] = n1->arr[1];
    N->n = 1;
    N->ptr[0] = n1;
    N->ptr[1] = n2;

    n2->arr[0] = n1->arr[2];
    n2->n = 1;
    n2->ptr[0] = n1->ptr[3];
    n2->ptr[1] = n1->ptr[4];
    n2->parent = N;

    n1->arr[1] = NULL;
    n1->arr[2] = NULL;

    n1->ptr[3] = NULL;
    n1->ptr[4] = NULL;

    N->parent = n1->parent;
    n1->parent = N;
    n1->n = 1;
    return 0;
}
//Разбиение узла вниз                               +
int SplitNode(Node* N)
{
    int i = 0, j = 2;
    //выделяем память под дочерние узлы
    for (i, j; i < 2; i++, j--) {
        Node* n = (Node*)calloc(1, sizeof(Node));
        n->arr = (Item*)calloc(3, sizeof(Item));
        n->arr[0] = N->arr[i];
        n->n++;
        n->parent = N;
        N->arr[i] = NULL;
        N->n--;
        if (N->arr[0] == NULL)
            ShiftNode(N, 1, 2);
        N->ptr[i] = n;
    }
    return 0;
}
//сдвиг элементов в узле  [1]-влево [2]-вправо      +
void ShiftNode(Node* N, int a, int b)
{
    int i;
    if (a == 1) {
        for (i = 0; N->arr[b] != NULL; i++) {
            N->arr[i] = N->arr[i + 1];
            N->ptr[i] = N->ptr[i + 1];
            N->ptr[i + 1] = N->ptr[i + 2];
            N->arr[i + 1] = NULL;
            N->ptr[i + 1] = NULL;
        }
    }
    else {
        for (i = 2; N->arr[b] != NULL; i--) {
            N->arr[i] = N->arr[i-1];
            if (N->ptr[i + 1]==NULL)
            N->ptr[i+1] = N->ptr[i];
            N->ptr[i] = N->ptr[i - 1];
            N->arr[i-1] = NULL;
            N->ptr[i-1] = NULL;
        }
    }
}
//поиск нужного указателя или положения Item        +
int SearchPTR(Node* N, int k)
{
    int i = 0, j=0;
    while (N->arr[i] != NULL && j < 3) {
        if (k > N->arr[i]->key)
            i++;
        j++;
    }
    return i;
}
//добавление элемета в узел                         +
void AddItemNode(Node* N,Item* I)
{
    if (N->arr[SearchPTR(N, I->key)] != NULL)
        ShiftNode(N, 2, SearchPTR(N, I->key));
    N->arr[SearchPTR(N, I->key)] = I;
    N->n++;
}
//                                      [ФУНКЦИИ РАБОТЫ С ТАБЛИЦЕЙ]        
//выделение памяти под структуру и пустые массивы   +         
Table* TableCreate(int size)
{
    Table* T;
    if (size <= 0)
        return NULL;
    //выделяем память под структуру таблицы
    T = (Table*)calloc(1, sizeof(Table));
    if (T == NULL)
        return NULL;
    if (Search(T))
        return NULL;
    if (T->arr == NULL)
        return NULL;
    return T;
}
//удаление таблицы                                              
void TableDelete(Table* T, Node* Nhead)
{
    free(T->arr);
    free(T);
    printf("Table was deleted.");
}
//вывод таблицы                                               
int TablePrint(Table* T, Node* Nhead)
{
    int k, i;
    int* arr;
    puts("\nTable:");
    printf("count = %d, size = %d.\n", T->count, T->size);
    printf("%2s %5s %8s\n", "i", "key2", "info");
    arr = MIN(T, Nhead);
    for (i = 0; i < T->count; i++) {     //проходим по массиву
        printf("%2d", i);
        if (T->arr[hash(&arr[i], SIZE)] != NULL)
            printf("%5d  %8s\n", T->arr[hash(&arr[i], SIZE)]->key, T->arr[hash(&arr[i], SIZE)]->info);
        else
            printf("%5d    (null)\n", 0);
    }
    for (i; i < T->size; i++) {
        printf("%2d", i);
        printf("%5d    (null)\n", 0);
    }
    return 0;
}
//загрузка таблицы                                  +  
int Search(Table* T)
{
    int choose;
    printf("Upload data from a file?\nYes[1]    No[2]\nEnter:");
    getInt(&choose);
    if (choose == 0)
        return 0;
    //если такого файла нет, то создаем таблицу
    if (load(T) == 0) {
        printf("File wasn't found.");
        create(T, SIZE);
    }
    return 0;
}
//считываем информацию из файла(если он существует) +                     
int load(Table* T)
{
    int i = 0;
    char a[4];
    FILE* file = fopen("1.txt", "r");
    fscanf(file, "%d%d", &T->size, &T->count);
    T->arr = (Item*)calloc(T->size, sizeof(Item));
    for (int i = 0; i < T->count; i++) {
        Item* I = (Item*)calloc(1, sizeof(Item));
        I->info = (char*)calloc(4, sizeof(char));
        fscanf(file, "%d%s", &I->key, I->info);
        T->arr[hash(&(I->key), SIZE)] = I;
    }
    fclose(file);
    return 1;
}
//создаем новую таблицу                             +   
int create(Table* T, int sz)
{
    T->size = sz;
    T->count = 0;
    T->arr = (Item*)calloc(T->size, sizeof(Item));
    if (T->arr == NULL)
        return 1;
    return 0;
}
//создание массива ключей по возрастанию
int* MIN(Table* T, Node* Nhead)
{
    int l = 0, i, k, count = T->count;
    int* arr;
    arr = (int*)calloc(T->count, sizeof(int));
    for (i = 0; i < T->size; i++)
        if (T->arr[i] != NULL) {
            arr[l] = T->arr[i]->key;
            l++;
        }
    for (l = 0; l < T->count; l++)
        for (i = 0; i + 1 < count; i++) {
            if (arr[i] < arr[i + 1]) {
                k = arr[i + 1];
                arr[i + 1] = arr[i];
                arr[i] = k;
            }
        }
    return arr;
}
//-возврат элемента, соответствующего ключу с максимальным значением   
Item* MAX(Table* T, int* i, Node* Nhead)
{
    int kMAX, k = *i, o;
    while (T->arr[k] == NULL)
        k++;
    kMAX = T->arr[k]->key;
    o = k;
    for (k = 1; k < T->size; k++) {
        if (T->arr[k] != NULL)
            if (T->arr[k]->key > kMAX) {
                kMAX = T->arr[k]->key;
                o = k;
            }
    }
    *i = o;
    return T->arr[o];
}
//                                           [ФУНКЦИИ ВВОДА]
//чтение целого числа                               +         
int getInt(int* a)
{
    int n, flag = 0;
    do
    {
        if (flag == 1) {
            printf("Error!\nRepeat:");
            scanf_s("%*[^\n]");
        }
        n = scanf("%d", a);
        if (*a == -1)
            n = -1;
        flag = 1;
    } while (n <= 0);
    scanf("%*c");
    return n;
}
//получаем строку из входного потока                +  
char* getstr()
{
    char* ptr = (char*)malloc(1);
    char buf[81];
    int n, len = 0;
    *ptr = '\0';
    do {
        n = scanf("%80[^\n]", buf);
        if (n < 0) {
            free(ptr);
            ptr = NULL;
            continue;
        }
        if (n == 0)
            scanf("%*c");
        else {
            len += strlen(buf);
            ptr = (char*)realloc(ptr, len + 1);
            strcat(ptr, buf);
        }
    } while (n > 0);
    return ptr;
}
//                                       [ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ]
//Выбор                                             +               
int choose(Table* T) {
    int n, m;
    printf("\nMax size of kash-table:[%d]", SIZE);
    printf("\nHow many Items do you want to add?\nEnter:");
    getInt(&n);
    if (n == 0)
        return 0;
    return n;
}
//хеш функция + 
int hash(int* key, int size)
{
    return (*key % size);
};
//Поиск ключа в кеш таблице +
int FindKey(Table* T, int key, int a, Node* Nhead) {
    int k = key;
    if (a == 1) {
        if (T->arr[hash(&k, SIZE)] != NULL) {
            if (T->arr[hash(&k, SIZE)]->key != key)
                return 1;
        }
        else
            return 1;
    }
    else {
        if (T->arr[hash(&k, SIZE)] != NULL) {
            if (T->arr[hash(&k, SIZE)]->key == key)
                return -1;
            else
                return 1;
        }
    }
    return 0;
}
//пустая таблица + 
int CheckTableFree(Table* T)
{
    if (T->count == 0) {
        puts("\nTable is free.");
        return 1;
    }
    return 0;
}
